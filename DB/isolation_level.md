# Isolation Level
동시에 여러개의 트랜잭션이 실행될 때,  
특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용 가능 여부를 결정하는 것

**Read Uncommitted (읽기 미확정)**
* 트랜잭션이 다른 트랜잭션에서 아직 커밋되지 않은 변경사항을 읽을 수 있다. 
* 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장 
* **`Dirty reads`** 현상 발생
> **참고** : **Dirty reads**란  트랜잭션이 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상

**Read Committed (읽기 확정)**
* 트랜잭션은 다른 트랜잭션에서 커밋된 변경사항만 읽을 수 있다.
* RDB에서 대부분 기본적으로 사용되고 있는 격리 수준이다.
* 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드 값을 가져온다.
* 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 하는 `REPEATABLE READ`의 정합성에 어긋난다. 
* 즉, “논리적 일관성이 없는 데이터” 현상 발생
 
**Repeatable READ (반복 가능한 읽기)**
* 트랜잭션 동안 조회한 데이터는 그 트랜잭션이 종료될 때까지 변경되지 않음을 보장한다.
* MySQL에서는 트랙잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽는다.
* UNDO 공간에 백업해두고 실제 레코드 값을 변경한다.
  * 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제한다.
  * Undo에 백업된 레코드가 많아지면서 MySQL 서버의 처리 성능이 떨어질 수 있다.
* 이러한 변경 방식은 **MVCC(Mutli Version Concurrency Control)** 라고 한다.
* `PHANTOM READ`가 발생할 수 있다. 이를 방지하기 위해서 쓰기 잠금을 걸어야 한다.
> 참고 : `PHANTOM READ`란 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상

**SERIALIZABLE (직렬화 가능)**
* 트랜잭션이 직렬적으로 실행된 것처럼 보장하여, 다른 트랜잭션의 간섭을 전혀 받지 않는다.
* 가장 엄격한 고립 수준이지만 동시성이 가장 낮다.
* `PHANTOM READ`가 발생하지 않는다.
* 데이터베이스에서 거의 사용되지 않는다.
