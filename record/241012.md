# [TIL] 2024.10.12 📘

## 📝 코딩테스트 풀이
- [Course Schedule](https://leetcode.com/problems/course-schedule/)  
- [작성코드](https://github.com/no-cy/TIL/blob/main/study/coding-test/java/Level2/207.%20Course%20Schedule.java) (10.13 17:31 수정)

## 🧑🏻‍💻 코딩테스트 문제 기준 이론 공부
- **그래프(grahp)**
  - 노드의 간선 연결 형태를 표현하기 위해 사용
  - 문제로 예를 들었을 때, `prerquisites[i] = [ai, bi]`는 **"과목 bi를 먼저 듣고 나서 과목 ai를 들어야 한다"** 라는 조건이 있으므로, **bi -> ai**로 향하는 방향이 있는 간선을 가지는 그래프를 만들 수 있음.
  - 그래프를 코드로 구현하기 위해서는 **인접 리스트(adjacency list)** 와 **인접 행렬(adjacency matrix)** 방식을 사용함
  ---
  > 💡 **인접 리스트(adjacency list)**  
  > **각 노드를 리스트로 나타내고, 그 리스트에 해당 노드와 연결된 다른 노드들을 저장함**  
  > 일반적으로 **배열이나 해시맵(HashMap)** 을 사용해 노드를 저장하고, 각 노드에 연결된 다른 노드들을 리스트로 저장하는 구조  
  > 대부분 **배열(ArrayList)** 같은 자료 구조를 많이 사용
  ```
  1 → [2, 3]
  2 → [4]
  3 → []
  ```
  ---
  > 💡 **인접 행렬(adjacency matrix)**  
  > **그래프를 2차원 배열로 표현하는 방식**  
  > 노드 간의 연결 여부를 0 또는 1로 표시
  > 즉, 행과 열이 각각 그래프의 노드를 나타내고, 만약 `graph[i][j]`가 1이라면, 노드 i와 노드 j가 연결되어 있다는 의미
  > 해당 방식은 **간선(edge)** 의 수가 많을 때, 즉 **밀접 그래프(dense graph)** 를 구현할 때 효울적임
  ```
      1  2  3  4
  ---------------
  1 | 0  1  1  0
  2 | 0  0  0  1
  3 | 0  0  0  0
  4 | 0  0  0  0
  ```
  ---
- **위상정렬(Topological Sort)**
  - 그래프에서 순서가 있는 작업을 순서대로 배치하는 방법
  - 위상정렬은 사이클이 없을 때만 모든 노드를 정렬할 수 있음
  - 만약 정렬이 불가능하면 사이클이 존재한다는 뜻
  - **너비 우선 탐색(BFS)** 과 **진입 차수(in-degree)** 를 사용하여 구현할 수 있음

